<template>
<view id="ruler-wrapper" class="ruler-wrapper">
  <view class="ruler-pointer" style="height:{{height / 8 * 7}}px;"></view>
  <scroll-view scroll-x scroll-left="{{center}}" scroll-with-animation="{{animation}}" @scroll="bindscroll" @touchstart="starttouch" @touchcancel="endtouch" @touchend="endtouch">
    <view class="scroll-wrapper">
      <view class="seat" style="width:{{componentWidth / 2 - padding / 2}}px;"></view>
      <view class="ruler-image" style="width:{{rulerWidth}}px; height:{{height}}px">
        <image wx:if="{{ruler}}" src="{{ruler}}"></image>
      </view>
      <view class="seat" style="width:{{componentWidth / 2 - padding / 2}}px;"></view>
    </view>
  </scroll-view>
</view>
<view class="ruler-canvas" style="width:{{rulerWidth}}px;">
  <canvas class="ruler-canvas" style="width:{{rulerWidth}}px;" canvas-id="ruler-canvas"></canvas>
</view>
</template>
<script>
import wepy from 'wepy';
import config from '../config';
import Debug from '../utils/debug';
import { validateImage } from '../utils/util';

const debug = Debug('ruler');

const { env, version } = config;

const radix = 10;
const scale = 10;
const rid = version;

export default class Ruler extends wepy.component {
  props = {
    // 最小值
    min: {
      type: Number,
      default: 0,
    },
    // 最大值
    max: {
      type: Number,
      default: 20,
    },
    // 展开小数，刻度扩大10倍
    expandDecimal: {
      type: Boolean,
      default: false,
    },
    // 单位内部跨度（只能是 1 ，2 ，5 一个能被10整除的数字 ）
    step: {
      type: Number,
      enum: [1, 2, 5],
      default: 1,
    },
    // 真实最小单位宽度 （单位px）
    single: {
      type: Number,
      default: 10,
    },
    // 卡尺左右的余量 ，最为60
    padding: {
      type: Number,
      default: 60,
    },
    // 高度
    height: {
      type: Number,
      default: 80,
    },
    // 当前选中
    active: {
      type: Number,
      default: 10,
    },
  };

  /**
   * 组件的初始数据
   */
  data = {
    animation: false,
    ruler: '',
    center: 0,
    _center: 0,
    _value: 0,
    componentWidth: 0,
  };

  computed = {
    // 刻度尺总跨度
    steps() {
      return this.max - this.min;
    },
    // 最小单位宽度
    unitWidth() {
      return this.single * this.step;
    },
    // 单位数量
    unitCount() {
      if (this.expandDecimal) {
        return (this.steps / this.step) * radix;
      }
      return this.steps / this.step;
    },
    // 刻度尺总宽度
    rulerWidth() {
      return (this.unitWidth * this.unitCount) + this.padding;
    },
  }

  /**
   * 组件的方法列表
   */
  methods = {
    /**
     * 获取滑动的值
     */
    bindscroll(e) {
      this.timer && clearTimeout(this.timer);

      // 移动距离
      const left = e.detail.scrollLeft;
      // 移动比率
      const resultRate = Math.round(left / this.unitWidth);
      // 还原实际数值
      const resultCenter = Math.round(resultRate * this.unitWidth);
      // 小数位处理
      const resultValue = !this.expandDecimal ? (resultRate * this.step) + this.min : (((resultRate * this.step) / radix) + this.min).toFixed(1);

      this._center = resultCenter;
      this._value = resultValue;

      this.$emit('ruler-value', resultValue);
      this.timer = setTimeout(() => {
        !this.touch && this.scrollFixed();
      }, 300);
    },
    starttouch() {
      this.touch = true;
      this.timer && clearTimeout(this.timer);
    },
    endtouch() {
      this.touch = false;
      this.timer && clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.scrollFixed();
      }, 300);
    },
  };

  events = {
    'ruler-setting': (value) => {
      this.setting(value);
    },
    'ruler-init': () => {
      this.init(true);
    },
  };

  scrollFixed() {
    debug.info('微调偏移', this._center, this._value);
    this.center = this._center;
    this.$apply();
    this.$emit('ruler-value', this._value);
  }

  /**
   * 优先读取缓存
   * 缓存无效，进行初始化
   */
  async init(force) {
    let ruler;
    let componentWidth;
    if (this.$root.$parent.globalData.RulerRenderFirst) {
      ruler = wx.getStorageSync(`${env}_ruler_${rid}`);
      componentWidth = wx.getStorageSync(`${env}_ruler_componentWidth`);
    } else {
      this.$root.$parent.globalData.RulerRenderFirst = true;
    }

    debug.info('ruler', ruler, componentWidth);

    if (!force && ruler && await validateImage(ruler)) {
      debug.info('ruler vaild');

      this.componentWidth = componentWidth;
      this.ruler = ruler;
      this.$apply();
      this.setting(this.active);
    } else {
      debug.info('ruler invaild');
      this.prepare();
    }
  }

  /**
   * 初始化卡尺
   */
  prepare() {
    debug.info('ruler prepare');
    // 获取 canvas context
    this.ctx = wx.createCanvasContext('ruler-canvas');
    //  获取节点信息，获取节点宽度
    wx.createSelectorQuery()
      .select('#ruler-wrapper')
      .boundingClientRect((res) => {
        this.componentWidth = res.width;
        wx.setStorageSync(`${env}_ruler_componentWidth`, this.componentWidth);
        this.draw();
      })
      .exec();
  }

  /**
   * 绘制
   * 生成卡尺
   */
  draw() {
    debug.info('ruler draw');
    // 绘制背景
    this.ctx.save();
    this.ctx.setFillStyle('#fbfbfb');
    this.ctx.fillRect(0, 0, this.rulerWidth, this.height);
    this.ctx.restore();
    // 绘制边线
    // this.ctx.beginPath();
    // this.ctx.setLineWidth(1);
    // this.ctx.setStrokeStyle('#dbdbdb');
    // this.ctx.moveTo(this.padding / 2, 0);
    // this.ctx.lineTo(this.rulerWidth - (this.padding / 2), 0);
    // this.ctx.stroke();
    for (let i = 0; i < this.unitCount + 1; i += 1) {
      // 绘制文字
      if (i % (radix / this.step) === 0) {
        this.ctx.setFontSize(18);
        this.ctx.setFillStyle('#404040');
        this.ctx.setTextAlign('center');
        if (!this.expandDecimal) {
          this.ctx.fillText((i * this.step) + this.min, (this.padding / 2) + (i * this.unitWidth), this.height - 15);
        } else {
          const value = (i / (radix / this.step)) + this.min;
          let text = value.toFixed(1);
          if (i === this.unitCount) {
            text = `${text}≤`;
          }
          this.ctx.fillText(text, (this.padding / 2) + (i * this.unitWidth), this.height - 15);
        }
      }
      // 绘制刻度
      if (i % scale === 0) {
        this.ctx.beginPath();
        this.ctx.setLineWidth(2);
        this.ctx.setStrokeStyle('#dbdbdb');
        this.ctx.moveTo((this.padding / 2) + (i * this.unitWidth), 0);
        this.ctx.lineTo((this.padding / 2) + (i * this.unitWidth), this.height / 2);
        this.ctx.stroke();
      } else {
        this.ctx.beginPath();
        this.ctx.setLineWidth(1);
        this.ctx.setStrokeStyle('#dbdbdb');
        this.ctx.moveTo((this.padding / 2) + (i * this.unitWidth), 0);
        this.ctx.lineTo((this.padding / 2) + (i * this.unitWidth), this.height / 7);
        this.ctx.stroke();
      }
    }
    this.ctx.draw(true, () => {
      wx.canvasToTempFilePath({
        x: 0,
        y: 0,
        width: this.rulerWidth,
        height: this.height,
        canvasId: 'ruler-canvas',
        success: (res) => {
          this.ruler = res.tempFilePath;
          wx.setStorageSync(`${env}_ruler_${rid}`, this.ruler);
          this.$apply();
          this.setting(this.active);
        },
        fail(e) {
          console.error('canvasToTempFilePath', e);
        },
      });
    });
  }

  setting(value, animation = true) {
    debug.info('setting', value);
    if (this.ruler) {
      let _realValue = value - this.min;
      if (this.expandDecimal) {
        _realValue *= 10;
      }
      this.animation = animation;
      this.center = _realValue * ((this.rulerWidth - this.padding) / this.unitCount);
      this.$apply();
    }
  }

  // onLoad() {
  //   this.init();
  // }
}
</script>
<style lang="less">
.ruler-wrapper {
  position: relative;
  width: 100%;
  box-sizing: border-box;
  // background: #dbdbdb;
}

.ruler-pointer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  width: 0px;
  margin: auto;
  border: 1px #52b8f5 solid;
  z-index: 999;
}

.scroll-wrapper {
  display: flex;
}

.ruler-image {
  flex-shrink: 0;
  box-sizing: border-box;

  image {
    width: 100%;
    height: 100%; 
  }
}

.seat {
  flex-shrink: 0;
  box-sizing: border-box;
}

.ruler-canvas {
  position: absolute;
  overflow: hidden;
  box-sizing: border-box;
  top: -100%;
  left:0;
  z-index: -1;
}
</style>

